import fs from 'fs';
import path from 'path';
import https from 'https';
import http from 'http';
import { spawn } from 'child_process';

/**
 * Extract frames from video URLs
 */
export class FrameExtractor {
  constructor(tempDir = './temp') {
    this.tempDir = path.resolve(tempDir);
    this.ensureTempDir();
  }

  ensureTempDir() {
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }
  }

  /**
   * Download video from URL
   */
  async downloadVideo(url, filename) {
    return new Promise((resolve, reject) => {
      const outputPath = path.join(this.tempDir, filename);
      const file = fs.createWriteStream(outputPath);
      const protocol = url.startsWith('https') ? https : http;

      protocol.get(url, (response) => {
        if (response.statusCode === 200) {
          response.pipe(file);
          file.on('finish', () => {
            file.close();
            resolve(outputPath);
          });
        } else if (response.statusCode === 302 || response.statusCode === 301) {
          file.close();
          fs.unlinkSync(outputPath);
          this.downloadVideo(response.headers.location, filename)
            .then(resolve)
            .catch(reject);
        } else {
          file.close();
          fs.unlinkSync(outputPath);
          reject(new Error(`Failed to download: HTTP ${response.statusCode}`));
        }
      }).on('error', (err) => {
        file.close();
        if (fs.existsSync(outputPath)) {
          fs.unlinkSync(outputPath);
        }
        reject(err);
      });
    });
  }

  /**
   * Extract last frame from video using ffmpeg
   */
  async extractLastFrame(videoPath, outputImagePath) {
    return new Promise((resolve, reject) => {
      // Try to use ffmpeg to extract the last frame
      const ffmpeg = spawn('ffmpeg', [
        '-sseof', '-1',           // Seek to 1 second before end
        '-i', videoPath,          // Input file
        '-update', '1',           // Update single image
        '-q:v', '1',             // High quality
        '-frames:v', '1',        // Extract 1 frame
        '-y',                    // Overwrite output
        outputImagePath
      ]);

      let stderr = '';

      ffmpeg.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      ffmpeg.on('close', (code) => {
        if (code === 0 && fs.existsSync(outputImagePath)) {
          resolve(outputImagePath);
        } else {
          reject(new Error(`ffmpeg failed: ${stderr}`));
        }
      });

      ffmpeg.on('error', (err) => {
        reject(new Error(`ffmpeg not found or failed to start: ${err.message}`));
      });
    });
  }

  /**
   * Get last frame from video URL
   */
  async getLastFrameFromURL(videoUrl, sceneNumber) {
    console.log(`\nðŸŽžï¸  Extracting last frame from previous clip for continuity...`);

    try {
      // Download video
      const videoFilename = `temp_video_${sceneNumber}.mp4`;
      console.log(`   Downloading video...`);
      const videoPath = await this.downloadVideo(videoUrl, videoFilename);

      // Extract last frame
      const frameFilename = `last_frame_${sceneNumber}.jpg`;
      const framePath = path.join(this.tempDir, frameFilename);

      console.log(`   Extracting last frame with ffmpeg...`);
      await this.extractLastFrame(videoPath, framePath);

      // Clean up video file
      fs.unlinkSync(videoPath);

      console.log(`   âœ… Frame extracted: ${framePath}`);
      return framePath;

    } catch (error) {
      console.error(`   âš ï¸  Could not extract frame: ${error.message}`);
      console.log(`   Continuing without frame continuity...`);
      return null;
    }
  }

  /**
   * Cleanup temp directory - ONLY removes generated temp files
   * Preserves user files like default_speaker.*
   */
  cleanup() {
    if (fs.existsSync(this.tempDir)) {
      const files = fs.readdirSync(this.tempDir);
      files.forEach(file => {
        // CRITICAL: Only delete files that were generated by this tool
        // DO NOT delete user-provided files like default_speaker.*
        const shouldDelete =
          file.startsWith('temp_video_') ||      // Downloaded videos for frame extraction
          file.startsWith('last_frame_') ||      // Extracted frames
          file.startsWith('voiceover_');         // Generated voiceovers (already cleaned up elsewhere)

        if (shouldDelete) {
          const filePath = path.join(this.tempDir, file);
          console.log(`   Removing temp file: ${file}`);
          fs.unlinkSync(filePath);
        }
      });
    }
  }
}
